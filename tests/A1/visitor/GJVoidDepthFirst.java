//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;
import java.io.PrintWriter;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJVoidDepthFirst<A> implements GJVoidVisitor<A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   class Pair<T1,T2>
   {
      public T1 first;
      public T2 second;
      public Pair(T1 f,T2 s)
      {
         first = f;
         second = s;
      }
   }
   class ClassTable
   {
      public LinkedHashMap<String,FunctionTable> functions = new LinkedHashMap<String,FunctionTable>();
      public String parent;
      public Hashtable<String,String> fields = new Hashtable<String,String>();
   }
   class FunctionTable
   {
      public String return_type;
      public String return_identfier;
      public Hashtable<String,String> local_variables = new Hashtable<String,String>();
      public LinkedHashMap<String,String> arguments = new LinkedHashMap<String,String>();
      public Hashtable<String,Set<String>> assignment_statements = new Hashtable<String,Set<String>>();
      public Hashtable<String,Set<Integer>> allocation_statements = new Hashtable<String,Set<Integer>>();
      public ArrayList<Pair<Pair<String,String>,String>> field_writes = new ArrayList<Pair<Pair<String,String>,String>>();
      public ArrayList<Pair<String,Pair<String,String>>> field_loads = new ArrayList<Pair<String,Pair<String,String>>>();
      public ArrayList<String[]> function_calls = new ArrayList<String[]>();
      public ArrayList<Pair<String,String>> queries = new ArrayList<Pair<String,String>>();
      public Hashtable<String,Set<Integer>> stack = new Hashtable<String,Set<Integer>>();
      public TreeMap<Pair<String,String>,Boolean> called_functions = new TreeMap<Pair<String,String>,Boolean>(string_cmp);
   }
   private PrintWriter pw = new PrintWriter(System.out,true);
   private Comparator<Pair<String,String>> string_cmp = new Comparator<Pair<String,String>>(){
      public int compare(Pair<String,String> p1,Pair<String,String> p2){
         int x = p1.first.compareTo(p2.first);
         if(x != 0)
            return (x < 0)?-1:1;
         else
         {
            x = p1.second.compareTo(p2.second);
            if(x != 0)
               return (x<0)?-1:1;
            else
               return 0;
         }
      }
   };
   private Comparator<Pair<Integer,String>> field_cmp = new Comparator<Pair<Integer,String>>(){
      public int compare(Pair<Integer,String> p1, Pair<Integer,String> p2){
         if(p1.first != p2.first)
            return (p1.first < p2.first)?-1:1;
         int y = p1.second.compareTo(p2.second);
         if(y != 0)
            return (y < 0)?-1:1;
         else return 0;
      }
   };
   private boolean part_of_call = false;
   private int abstract_locations = 1;
   private int statement_type = -1;
   private int inline_allocations = 0;
   private Hashtable<Integer,String> abstract_types = new Hashtable<Integer,String>();
   private ClassTable class_object;
   private FunctionTable function_object;
   private LinkedHashMap<String,ClassTable> classes = new LinkedHashMap<String,ClassTable>();
   private String current_class;
   private String current_function;
   private String tokenName;
   private String exp_id1,exp_id2;
   private ArrayList<String> message_send = new ArrayList<String>();
   private TreeMap<Pair<Integer,String>,Set<Integer>> heap_fields = new TreeMap<Pair<Integer,String>,Set<Integer>>(field_cmp);
   private void print_heap()
   {
      pw.printf("---------\n");
      for(Pair<Integer,String> p: heap_fields.keySet())
      {
         pw.printf("(%d,%s): {",p.first,p.second);
         for(int x: heap_fields.get(p))
            pw.printf("%d,",x);
         pw.printf("}\n");
      }
      pw.printf("----------\n");
   }
   private void print_answers()
   {
      for(String cl: classes.keySet())
      {
         ClassTable ct1 = classes.get(cl);
         for(String fn: ct1.functions.keySet())
         {
            FunctionTable ft1 = ct1.functions.get(fn);
            for(Pair<String,String> p: ft1.queries)
            {
               Set<Integer> s1 = new HashSet<Integer>();
               Set<Integer> s2 = new HashSet<Integer>();
               String ty1 = get_type_from_obj(p.first,cl,ft1);
               String ty2 = get_type_from_obj(p.second,cl,ft1);
               if(classes.containsKey(ty1))
               {
                  if(classes.containsKey(ty2))
                  {
                     //can alias. Get points-to info. 
                     if(ft1.local_variables.containsKey(p.first) || ft1.arguments.containsKey(p.first))
                        s1.addAll(ft1.stack.get(p.first));
                     else
                     {
                        Set<Integer> s3 = ft1.stack.get("this");
                        Pair<Integer,String> p1 = new Pair<Integer,String>(0,p.first);
                        for(int x: s3)
                        {
                           p1.first = x;
                           s1.addAll(heap_fields.get(p1));
                        }
                     }
                     if(ft1.local_variables.containsKey(p.second) || ft1.arguments.containsKey(p.second))
                        s2.addAll(ft1.stack.get(p.second));
                     else
                     {
                        Set<Integer> s3 = ft1.stack.get("this");
                        Pair<Integer,String> p1 = new Pair<Integer,String>(0,p.second);
                        for(int x: s3)
                        {
                           p1.first = x;
                           s2.addAll(heap_fields.get(p1));
                        }
                     }
                     //pw.printf("Before filtering: %s %s\n",s1.toString(),s2.toString());
                     s1.retainAll(s2);
                     //pw.printf("%s alias? %s: %s\n",p.first,p.second,s1.toString());
                     if(s1.size() == 0)
                        pw.println("No");
                     else
                        pw.println("Yes");
                  }
                  else
                  {
                     pw.println("No");
                     continue;
                  }
               }
               else
               {
                  if(classes.containsKey(ty2))
                  {
                     pw.println("No");
                     continue;
                  }
                  else
                  {
                     if(!ty1.equals("int[]") || !ty2.equals("int[]"))
                     {
                        pw.println("No");
                        continue;
                     }
                     //can alias as int[] arrays. Get points-to info. 
                     if(ft1.local_variables.containsKey(p.first) || ft1.arguments.containsKey(p.first))
                        s1 = ft1.stack.get(p.first);
                     else
                     {
                        s1 = new HashSet<Integer>();
                        Set<Integer> s3 = ft1.stack.get("this");
                        Pair<Integer,String> p1 = new Pair<Integer,String>(0,p.first);
                        for(int x: s3)
                        {
                           p1.first = x;
                           s1.addAll(heap_fields.get(p1));
                        }
                     }
                     if(ft1.local_variables.containsKey(p.second) || ft1.arguments.containsKey(p.second))
                        s2 = ft1.stack.get(p.second);
                     else
                     {
                        s2 = new HashSet<Integer>();
                        Set<Integer> s3 = ft1.stack.get("this");
                        Pair<Integer,String> p1 = new Pair<Integer,String>(0,p.second);
                        for(int x: s3)
                        {
                           p1.first = x;
                           s2.addAll(heap_fields.get(p1));
                        }
                     }
                     s1.retainAll(s2);
                     if(s1.size() == 0)
                        pw.println("No");
                     else
                        pw.println("Yes");
                  }
               }
            }
         }
      }
      //end of printing queries. 
   }
   private boolean is_subtype(String base_class, String derived_class)
   {
      ClassTable ct;
      while(derived_class != null)
      {
         if(derived_class.equals(base_class))
            return true;
         ct = classes.get(derived_class);
         derived_class = ct.parent;
      }
      return false;
   }
   private String get_type_from_obj(String id, String cl,FunctionTable f)
   {
      if(f.local_variables.containsKey(id))
         return f.local_variables.get(id);
      else if(f.arguments.containsKey(id))
         return f.arguments.get(id);
      else
      {
         while(cl != null)
         {
            ClassTable ct = classes.get(cl);
            if(ct.fields.containsKey(id))
               return ct.fields.get(id);
            cl = ct.parent;
         }
         return null;
      }
   }
   private Pair<String,Integer> get_type(String id)
   {
      //first = type of variable, second = 1 for function arg/local, 2 for class var. 
      if(function_object.local_variables.containsKey(id))
         return new Pair<String,Integer>(function_object.local_variables.get(id),1);
      else if(function_object.arguments.containsKey(id))
         return new Pair<String,Integer>(function_object.arguments.get(id),1);
      else
      {
         String curr_cl = current_class;
         while(curr_cl != null)
         {
            ClassTable ct = classes.get(curr_cl);
            if(ct.fields.containsKey(id))
               return new Pair<String,Integer>(ct.fields.get(id),2);
            curr_cl = ct.parent;
         }
      }
      return null;
   }
   private boolean set_equal(Set<Integer> s1,Set<Integer> s2)
   {
      if(s1.size() != s2.size())
         return false;
      for(int x: s1)
      {
         if(!s2.contains(x))
            return false;
      }
      return true;
   }
   private boolean heap_equal(TreeMap<Pair<Integer,String>,Set<Integer>> t1, TreeMap<Pair<Integer,String>,Set<Integer>> t2)
   {
      if(t1.size() != t2.size())
         return false;
      for(Pair<Integer,String> p: t1.keySet())
      {
         if(!t2.containsKey(p))
            return false;
         Set<Integer> s1 = t1.get(p);
         Set<Integer> s2 = t2.get(p);
         if(!set_equal(s1, s2))
            return false;
      }
      return true;
   }
   private boolean stack_equal(Hashtable<String,Set<Integer>> h1,Hashtable<String,Set<Integer>> h2)
   {
      if(h1.size() != h2.size())
         return false;
      for(String s: h1.keySet())
      {
         if(!h2.containsKey(s))
            return false;
         Set<Integer> s1 = h1.get(s);
         Set<Integer> s2 = h2.get(s);
         if(!set_equal(s1, s2))
            return false;
      }
      return true;
   }
   private String get_field_type(String class_type,String id)
   {
      ClassTable ct;
      while(class_type != null)
      {
         ct = classes.get(class_type);
         if(ct.fields.containsKey(id))
            return ct.fields.get(id);
         class_type = ct.parent;
      }
      return null;
   }
   private boolean can_call(String curr_type, String base_type,String fn_name)
   {
      ClassTable ct;
      while(curr_type != null)
      {
         ct = classes.get(curr_type);
         if(ct.functions.containsKey(fn_name))
            return curr_type.equals(base_type);
         curr_type = ct.parent;
      }
      return false;
   }
   private void debug_symbol_info()
   {
      ClassTable ct;
      FunctionTable ft;
      for(String cl: classes.keySet())
      {
         ct = classes.get(cl);
         pw.printf("Class name: %s\n",cl);
         for(String f: ct.fields.keySet())
         {
            pw.printf("%s %s\n",ct.fields.get(f),f);
         }
         for(String fn: ct.functions.keySet())
         {
            ft = ct.functions.get(fn);
            pw.printf("Method name: %s\n",fn);
            pw.printf("Locals:\n");
            for(String l: ft.local_variables.keySet())
            {
               pw.printf("%s %s\n",ft.local_variables.get(l),l);
            }
            pw.printf("Arguments:\n");
            for(String a: ft.arguments.keySet())
            {
               pw.printf("%s %s\n",ft.arguments.get(a),a);
            }
            pw.printf("Calls made:\n");
            for(String[] a: ft.function_calls)
            {
               pw.printf("%s = %s.%s(",a[0],a[1],a[2]);
               for(int i = 3;i < a.length;i++)
                  pw.printf("%s,",a[i]);
               pw.printf(")\n");
            }
            pw.printf("Allocation Statements:\n");
            for(String s: ft.allocation_statements.keySet())
            {
               Set<Integer> s1 = ft.allocation_statements.get(s);
               pw.printf("%s: {",s);
               for(int x: s1)
                  pw.printf("%d,",x);
               pw.printf("}\n");
            }
            pw.printf("Assignment statements:\n");
            for(String as: ft.assignment_statements.keySet())
            {
               Set<String> s1 = ft.assignment_statements.get(as);
               pw.printf("%s: {",as);
               for(String x: s1)
                  pw.printf("%s,",x);
               pw.printf("}\n");
            }
            pw.printf("Field loads:\n");
            for(Pair<String,Pair<String,String>> p: ft.field_loads)
            {
               pw.printf("%s = %s.%s\n",p.first,p.second.first,p.second.second);
            }
            pw.printf("Field writes:\n");
            for(Pair<Pair<String,String>,String> p: ft.field_writes)
            {
               pw.printf("%s.%s = %s\n",p.first.first,p.first.second,p.second);
            }
            pw.printf("Queries:\n");
            for(Pair<String,String> p: ft.queries)
            {
               pw.printf("%s alias? %s\n",p.first,p.second);
            }
         }
      }
   }
   private void debug_points_to_info()
   {
      pw.printf("Current heap state\n");
      for(Pair<Integer,String> p: heap_fields.keySet())
      {
         Set<Integer> s = heap_fields.get(p);
         pw.printf("(%d,%s): %s\n",p.first,p.second,s.toString());
      }
         ClassTable ct;
         FunctionTable ft;
         for(String cl: classes.keySet())
         {
            ct = classes.get(cl);
            pw.printf("Class name: %s\n",cl);
            for(String fn: ct.functions.keySet())
            {
               ft = ct.functions.get(fn);
               pw.printf("Method name: %s\nCurrent stack state:\n",fn);
               for(String s: ft.stack.keySet())
               {
                  Set<Integer> s1 = ft.stack.get(s);
                  pw.printf("%s: %s\n",s,s1.toString());
               }
            }
         }
   }
   private void solve_equation()
   {
      Queue<Pair<String,String>> q = new LinkedList<Pair<String,String>>();
      for(String cl: classes.keySet())
      {
         ClassTable ct = classes.get(cl);
         for(String fn: ct.functions.keySet())
            q.add(new Pair<String,String>(cl,fn));
      }
      
      for(int l1: abstract_types.keySet())
      {
         String ty = abstract_types.get(l1);
         if(ty.equals("int[]"))
         {
            continue;
         }
         while(ty != null)
         {
            ClassTable ct = classes.get(ty);
            for(String f: ct.fields.keySet())
            {
               String ty1 = ct.fields.get(f);
               if(classes.containsKey(ty1) || ty1.equals("int[]")){
                  heap_fields.put(new Pair<Integer,String>(l1,f),new HashSet<Integer>());
               }
            }
            ty = ct.parent;
         }
      }
           
      while(!q.isEmpty())
      {
         Pair<String,String> p = q.poll();
         //pw.printf("Worklist is processing %s_%s\n",p.first,p.second);
         ClassTable ct = classes.get(p.first);
         FunctionTable ft = ct.functions.get(p.second);
         Hashtable<String,Set<Integer>> new_stack = new Hashtable<String,Set<Integer>>();
         
         TreeMap<Pair<Integer,String>,Set<Integer>> old_heap_fields = new TreeMap<Pair<Integer,String>,Set<Integer>>(field_cmp);
         for(Pair<Integer,String> p1: heap_fields.keySet())
         {
            Set<Integer> s1 = heap_fields.get(p1);
            Set<Integer> s2 = new HashSet<Integer>();
            s2.addAll(s1);
            old_heap_fields.put(new Pair<Integer,String>(p1.first,p1.second),s2);
         }
         //set all stack values to empty set
         
         for(Map.Entry<String,Set<Integer>> e: ft.stack.entrySet())
         {
            String s1 = e.getKey();
            Set<Integer> s2 = new HashSet<Integer>();
            s2.addAll(e.getValue());
            new_stack.put(s1,s2);
         }

         //start processing statements now.

         for(String s: ft.allocation_statements.keySet())
         {
            Set<Integer> s1 = ft.allocation_statements.get(s);
            if(ft.local_variables.containsKey(s) || ft.arguments.containsKey(s))
            {
               Set<Integer> s2 = new_stack.get(s);
               s2.addAll(s1);
            }
            else
            {
               Set<Integer> s2 = new_stack.get("this");
               Pair<Integer,String> p3 = new Pair<Integer,String>(0,s);
               for(int x: s2)
               {
                  p3.first = x;
                  Set<Integer> s3 = heap_fields.get(p3);
                  s3.addAll(s1);
               }
            }
         }
         
         for(String s: ft.assignment_statements.keySet())
         {
            Set<Integer> upd_val = new HashSet<Integer>();
            Set<String> s2 = ft.assignment_statements.get(s);
            //pw.printf("Assgt: %s, %s\n",s,s2);
            for(String t: s2)
            {
               if(ft.local_variables.containsKey(t) || ft.arguments.containsKey(t))
                  upd_val.addAll(new_stack.get(t));
               else
               {
                  Set<Integer> sg = new_stack.get("this");
                  Pair<Integer,String> sp = new Pair<Integer,String>(0,t);
                  for(int x:sg)
                  {
                     sp.first = x;
                     upd_val.addAll(heap_fields.get(sp));
                  }
               }
            }
            if(ft.local_variables.containsKey(s) || ft.arguments.containsKey(s))
            {
               Set<Integer> u = new_stack.get(s);
               u.addAll(upd_val);
            }
            else
            {
               Pair<Integer,String> sp = new Pair<Integer,String>(0,s);
               for(int x: new_stack.get("this"))
               {
                  sp.first = x;
                  Set<Integer> u = heap_fields.get(sp);
                  u.addAll(upd_val);
               }
            }
         }
         
         for(Pair<String,Pair<String,String>> p1: ft.field_loads)
         {
            String lhs = p1.first;
            String rhs_1 = p1.second.first;
            String rhs_2 = p1.second.second;
            Pair<Integer,String> p2 = new Pair<Integer,String>(0,rhs_1);
            //read the heap first, and see if we need to do a double read or a single read.
            Set<Integer> abs_set = new HashSet<Integer>();//final values.
            Set<Integer> s1 = new HashSet<Integer>();
            if(ft.local_variables.containsKey(rhs_1) || ft.arguments.containsKey(rhs_1))
            {
               s1.addAll(new_stack.get(rhs_1));
            }
            else
            {
               //read under implicit this pointer.
               Set<Integer> s3 = new_stack.get("this");
               for(int al: s3)
               {
                  p2.first = al;
                  s1.addAll(heap_fields.get(p2));
               }
            }
            p2.second = rhs_2;
            for(int x: s1)
            {
               p2.first=x;
               abs_set.addAll(heap_fields.get(p2));
            }
            if(ft.local_variables.containsKey(lhs) || ft.arguments.containsKey(lhs))
            {
               Set<Integer> cs = new_stack.get(lhs);
               cs.addAll(abs_set);
            }
            else
            {
               //weak update of heap.
               p2.second = lhs;
               Set<Integer> sx = new_stack.get("this");
               for(int al: sx)
               {
                  p2.first = al;
                  Set<Integer> sy = heap_fields.get(p2);
                  sy.addAll(abs_set);
               }
            }
         }
         
         for(Pair<Pair<String,String>,String> p1: ft.field_writes)
         {
            String lhs_1 = p1.first.first;
            String lhs_2 = p1.first.second;
            String rhs = p1.second;
            Pair<Integer,String> p2 = new Pair<Integer,String>(0,"");
            Set<Integer> abs_set;
            Set<Integer> s1;
            if(ft.local_variables.containsKey(lhs_1) || ft.arguments.containsKey(lhs_1))
            {
               s1 = new_stack.get(lhs_1);
            }
            else
            {
               s1 = new HashSet<Integer>();
               p2.second = lhs_1;
               Set<Integer> s2 = new_stack.get("this");
               for(int x: s2)
               {
                  p2.first = x;
                  s1.addAll(heap_fields.get(p2));
               }
            }
            if(ft.local_variables.containsKey(rhs) || ft.arguments.containsKey(rhs))
            {
               abs_set = new_stack.get(rhs);
            }
            else
            {
               abs_set = new HashSet<Integer>();
               Set<Integer> s2 = new_stack.get("this");
               p2.second = rhs;
               for(int x: s2)
               {
                  p2.first = x;
                  abs_set.addAll(heap_fields.get(p2));
               }
            }
            p2.second = lhs_2;
            for(int x: s1)
            {
               p2.first = x;
               Set<Integer> s2 = heap_fields.get(p2);
               s2.addAll(abs_set);
            }
         }
         
         for(String[] a: ft.function_calls)
         {
            //update to check if calling object is actually class/int[] type or not.
            boolean update_lhs = false;
            String tya;
            Pair<Integer,String> p2 = new Pair<Integer,String>(0,"");
            int n = a.length;
            String lhs = a[0];
            if(ft.local_variables.containsKey(lhs))
               tya = ft.local_variables.get(lhs);
            else if(ft.arguments.containsKey(lhs))
               tya = ft.arguments.get(lhs);
            else
            {
               tya = "";
               String cl = p.first;
               while(cl != null)
               {
                  ClassTable cty = classes.get(cl);
                  if(cty.fields.containsKey(lhs))
                  {
                     tya = cty.fields.get(lhs);
                     break;
                  }
                  cl = cty.parent;
               }
            }
            update_lhs = (classes.containsKey(tya) || tya.equals("int[]"));
            String caller_obj = a[1];
            String called_fn = a[2];//rest are arguments.
            TreeMap<Pair<String,String>,Boolean> candidates = new TreeMap<Pair<String,String>,Boolean>(string_cmp);
            Set<Integer> caller_set;
            if(ft.local_variables.containsKey(caller_obj) || ft.arguments.containsKey(caller_obj))
               caller_set = new_stack.get(caller_obj);
            else
            {
               Set<Integer> this_set = new_stack.get("this");
               p2.second = caller_obj;
               caller_set = new HashSet<Integer>();
               for(int x:this_set)
               {
                  p2.first = x;
                  caller_set.addAll(heap_fields.get(p2));
               }
            }
            for(int al: caller_set)
            {
               String ty = abstract_types.get(al);//runtime type. Now look for the candidate callees.
               while(ty != null)
               {
                  ClassTable curr_cl = classes.get(ty);
                  if(curr_cl.functions.containsKey(called_fn))
                  {
                     candidates.put(new Pair<String,String>(ty,called_fn),true);
                     break;
                  }
                  ty = curr_cl.parent;
               }
            }
            Set<Integer> return_value = new HashSet<Integer>();
            //pw.printf("In %s_%s, %d candidates\n",p.first,p.second,candidates.size());
            for(Pair<String,String> call_pair: candidates.keySet())
            {
               //check if this is a recursive call candidate. 
              if(p.first.compareTo(call_pair.first) == 0 && p.second.compareTo(call_pair.second) == 0)
              {
                 boolean change = false;
                 //this is a recursive call. Meet formals with current actuals, and calculate return value.
                 Set<Integer> obj_set = new HashSet<Integer>();
                 if(ft.local_variables.containsKey(caller_obj) || ft.arguments.containsKey(caller_obj))
                  obj_set.addAll(new_stack.get(caller_obj));
                 else
                 {
                    Set<Integer> ts = new_stack.get("this");
                    Pair<Integer,String> ps = new Pair<Integer,String>(0,caller_obj);
                    for(int x : ts)
                    {
                        ps.first = x;
                        obj_set.addAll(heap_fields.get(ps));
                    }
                 }
                 obj_set.removeIf(entry -> !can_call(abstract_types.get(entry),call_pair.first,call_pair.second));//keep only relevant abstract locations.
                 Set<Integer> hs = new_stack.get("this");
                 int sz = hs.size();
                 hs.addAll(obj_set);
                 if(hs.size() > sz)
                  change = true;
                 int i = 3;
                 for(String formal: ft.arguments.keySet())
                 {
                    if(formal.equals("this"))
                     continue;
                    String ac_arg = a[i];
                    i++;
                    Set<Integer> arg_set;
                    String ty = ft.arguments.get(formal);
                    if(!classes.containsKey(ty) && !ty.equals("int[]"))
                     continue;//not a reference type. 
                    if(ft.local_variables.containsKey(ac_arg) || ft.arguments.containsKey(ac_arg))
                     arg_set = new_stack.get(ac_arg);
                    else
                    {
                       arg_set = new HashSet<Integer>();
                       Set<Integer> ts = new_stack.get("this");
                       Pair<Integer,String> ps = new Pair<Integer,String>(0,ac_arg);
                       for(int x: ts)
                       {
                          ps.first = x;
                          arg_set.addAll(heap_fields.get(ps));
                       }
                    }
                    Set<Integer> sh = new_stack.get(formal);
                    int x = sh.size();
                    sh.addAll(arg_set);
                    if(sh.size() > x)
                     change = true;
                 }
                 if(update_lhs)
                 {
                    String rv = ft.return_identfier;
                    if(ft.local_variables.containsKey(rv) || ft.arguments.containsKey(rv))
                    {
                       return_value.addAll(ft.stack.get(rv));
                    }
                    else
                    {
                       Set<Integer> sr = ft.stack.get("this");
                       Pair<Integer,String> ps = new Pair<Integer,String>(0,rv);
                       for(int x: sr)
                       {
                          ps.first = x;
                          return_value.addAll(heap_fields.get(ps));
                       }
                    }
                    if(ft.local_variables.containsKey(lhs) || ft.arguments.containsKey(lhs))
                    {
                       Set<Integer> vs = new_stack.get(lhs);
                       vs.addAll(return_value);
                    }
                    else
                    {
                       Set<Integer> ts = new_stack.get("this");
                       Pair<Integer,String> ps = new Pair<Integer,String>(0,lhs);
                       for(int x: ts)
                       {
                          ps.first = x;
                          Set<Integer> hs1 = heap_fields.get(ps);
                          hs1.addAll(return_value);
                       }
                    }
                 }
                 //if change, then not to worry. It'll be added on it's own later as the stack would have changed. 
                 continue;
              }

               ClassTable cl = classes.get(call_pair.first);
               FunctionTable callee = cl.functions.get(call_pair.second);
               int i = 3;
               boolean change = false;
               String rv = callee.return_identfier;
               if(update_lhs){
                  if(callee.local_variables.containsKey(rv) || callee.arguments.containsKey(rv))
                  {
                        return_value.addAll(callee.stack.get(rv));
                  }
                  else
                  {
                     Set<Integer> rs = callee.stack.get("this");
                     p2.second = rv;
                     for(int x: rs)
                     {
                        p2.first = x;
                        return_value.addAll(heap_fields.get(p2));
                     }  
                  }
                  if(new_stack.containsKey(lhs))
                  {
                     Set<Integer> st = new_stack.get(lhs);
                     st.addAll(return_value);
                  }
                  else
                  {
                     Pair<Integer,String> upd = new Pair<Integer,String>(0,lhs);
                     for(int x: new_stack.get("this"))
                     {
                        upd.first = x;
                        Set<Integer> us = heap_fields.get(upd);
                        us.addAll(return_value);
                     }
                  }
               }
               Set<Integer> sc = new HashSet<Integer>();
               if(ft.local_variables.containsKey(caller_obj) || ft.arguments.containsKey(caller_obj))
               {
                  sc.addAll(new_stack.get(caller_obj));
               }
               else
               {
                  Set<Integer> sh = new_stack.get("this");
                  Pair<Integer,String> ps = new Pair<Integer,String>(0,caller_obj);
                  for(int x: sh)
                  {
                     ps.first=x;
                     sc.addAll(heap_fields.get(ps));
                  }
               }
               sc.removeIf(entry -> !can_call(abstract_types.get(entry),call_pair.first,call_pair.second));
               Set<Integer> cset = callee.stack.get("this");//update this set.
               Set<Integer> old_set = new HashSet<Integer>(cset);
               cset.addAll(sc);
               if(!set_equal(cset, old_set))
                  change = true;

               for(String formal: callee.arguments.keySet())
               {
                  if(formal.equals("this"))
                     continue;
                  String actual = a[i];
                  i++;
                  String ty1 = callee.arguments.get(formal);
                  if(!classes.containsKey(ty1) && !ty1.equals("int[]"))
                        continue;
                  
                  Set<Integer> ac_arg;
                  if(ft.local_variables.containsKey(actual) || ft.arguments.containsKey(actual))
                     ac_arg = new_stack.get(actual);
                  else
                  {
                     ac_arg = new HashSet<Integer>();
                     Set<Integer> as = new_stack.get("this");
                     p2.second = actual;
                     for(int x: as)
                     {
                        p2.first = x;
                        ac_arg.addAll(heap_fields.get(p2));
                     }
                  }
                  
                  Set<Integer> curr = callee.stack.get(formal);
                  Set<Integer> s2 = new HashSet<Integer>();
                  s2.addAll(curr);
                  curr.addAll(ac_arg);
                  if(!set_equal(s2, curr))
                  {
                     change = true;
                  }
               }
               if(change){
                  q.add(call_pair);//has to be processed due to change in values. 
                  //pw.printf("%s_%s was added by %s_%s\n",call_pair.first,call_pair.second,p.first,p.second);
               }
            }
         }
         if(!heap_equal(heap_fields, old_heap_fields))
         {
            //add all callers of the current function into the worklist.
            //pw.printf("Heap changed in %s_%s!\n",p.first,p.second);
            for(String cl: classes.keySet())
            {
               ClassTable ct1 = classes.get(cl);
               for(String fn: ct1.functions.keySet())
               {
                  q.add(new Pair<String,String>(cl,fn));//caller, so add it. 
               }
            } 
         }
         
         if(!stack_equal(new_stack, ft.stack))
         {
            //pw.printf("Stack of %s_%s has changed!\n",p.first,p.second);
            ft.stack = new_stack;
            q.add(p);//have to reanalyze!
         }
      }
   }
   public void visit(NodeList n, A argu) {
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
   }

   public void visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
      }
   }

   public void visit(NodeOptional n, A argu) {
      if ( n.present() )
         n.node.accept(this,argu);
   }

   public void visit(NodeSequence n, A argu) {
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
   }

   public void visit(NodeToken n, A argu) {
      tokenName = n.tokenImage;
   }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public void visit(Goal n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
      else if(x == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         //debug_symbol_info();
         solve_equation();
         //debug_points_to_info();
         print_answers();
      }
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> ( VarDeclaration() )*
    * f15 -> ( QStatement() )*
    * f16 -> "}"
    * f17 -> "}"
    */
   public void visit(MainClass n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         current_function = "main";
         class_object = new ClassTable();
         function_object = new FunctionTable();
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         n.f8.accept(this, argu);
         n.f9.accept(this, argu);
         n.f10.accept(this, argu);
         n.f11.accept(this, argu);
         String id = tokenName;
         function_object.arguments.put(id,"String[]");
         function_object.arguments.put("this",current_class);
         n.f12.accept(this, argu);
         n.f13.accept(this, argu);
         n.f14.accept(this, argu);
         n.f15.accept(this, argu);
         n.f16.accept(this, argu);
         n.f17.accept(this, argu);
         class_object.functions.put("main",function_object);
         classes.put(current_class,class_object);
         class_object= null;
         function_object = null;
         current_class = current_function = null;
      }
      else if(x == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         class_object = classes.get(current_class);
         current_function = "main";
         function_object = class_object.functions.get("main");
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         n.f8.accept(this, argu);
         n.f9.accept(this, argu);
         n.f10.accept(this, argu);
         n.f11.accept(this, argu);
         n.f12.accept(this, argu);
         n.f13.accept(this, argu);
         n.f14.accept(this, argu);
         n.f15.accept(this, argu);
         n.f16.accept(this, argu);
         n.f17.accept(this, argu);
         for(String lv: function_object.local_variables.keySet())
         {
            String ty = function_object.local_variables.get(lv);
            if(classes.containsKey(ty) || ty.equals("int[]"))
            {
               function_object.stack.put(lv,new HashSet<Integer>());
            }
         }
         for(String lv: function_object.arguments.keySet())
         {
            String ty = function_object.arguments.get(lv);
            if(classes.containsKey(ty) || ty.equals("int[]"))
            {
               function_object.stack.put(lv,new HashSet<Integer>());
            }
         }
         function_object = null;
         current_function = null;
      }
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public void visit(TypeDeclaration n, A argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public void visit(ClassDeclaration n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         class_object = new ClassTable();
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         classes.put(current_class,class_object);
         current_class = null;
         class_object = null;
      }
      else if(x == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         class_object = classes.get(current_class);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
      }
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public void visit(ClassExtendsDeclaration n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         class_object = new ClassTable();
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         class_object.parent = tokenName;
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         classes.put(current_class,class_object);
         current_class = current_function = null;
         class_object = null;
      }
      else if(x == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         current_class = tokenName;
         class_object = classes.get(current_class);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);  
      }
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public void visit(VarDeclaration n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
         String ty = tokenName;
         n.f1.accept(this, argu);
         String id = tokenName;
         if(function_object == null)
            class_object.fields.put(id,ty);
         else
            function_object.local_variables.put(id,ty);
         n.f2.accept(this, argu);
      }
      else if(x == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);  
      }
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( QStatement() )*
    * f9 -> "return"
    * f10 -> Identifier()
    * f11 -> ";"
    * f12 -> "}"
    */
   public void visit(MethodDeclaration n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         String return_type = tokenName;
         n.f2.accept(this, argu);
         current_function = tokenName;
         function_object = new FunctionTable();
         function_object.return_type = return_type;
         function_object.arguments.put("this",current_class);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         n.f8.accept(this, argu);
         n.f9.accept(this, argu);
         n.f10.accept(this, argu);
         function_object.return_identfier = tokenName;
         n.f11.accept(this, argu);
         n.f12.accept(this, argu);
         class_object.functions.put(current_function,function_object);
         current_function = null;
         function_object = null;
      }
      else if(x == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         String return_type = tokenName;
         n.f2.accept(this, argu);
         current_function = tokenName;
         function_object = class_object.functions.get(current_function);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         n.f6.accept(this, argu);
         n.f7.accept(this, argu);
         n.f8.accept(this, argu);
         n.f9.accept(this, argu);
         n.f10.accept(this, argu);
         n.f11.accept(this, argu);
         n.f12.accept(this, argu);
         for(String lv: function_object.local_variables.keySet())
         {
            String ty = function_object.local_variables.get(lv);
            if(classes.containsKey(ty) || ty.equals("int[]"))
            {
               function_object.stack.put(lv,new HashSet<Integer>());
            }
         }
         for(String lv: function_object.arguments.keySet())
         {
            String ty = function_object.arguments.get(lv);
            if(classes.containsKey(ty) || ty.equals("int[]"))
            {
               function_object.stack.put(lv,new HashSet<Integer>());
            }
         }

         current_function = null;
         function_object = null;
      }
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public void visit(FormalParameterList n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public void visit(FormalParameter n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
         String ty = tokenName;
         n.f1.accept(this, argu);
         String id = tokenName;
         function_object.arguments.put(id,ty);
      }
      else if(x ==1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public void visit(FormalParameterRest n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public void visit(Type n, A argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public void visit(ArrayType n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      tokenName = "int[]";
   }

   /**
    * f0 -> "boolean"
    */
   public void visit(BooleanType n, A argu) {
      n.f0.accept(this, argu);
      tokenName = "boolean";
   }

   /**
    * f0 -> "int"
    */
   public void visit(IntegerType n, A argu) {
      n.f0.accept(this, argu);
      tokenName = "int";
   }

   /**
    * f0 -> ( Query() )*
    * f1 -> Statement()
    */
   public void visit(QStatement n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
   }

   /**
    * f0 -> <SCOMMENT1>
    * f1 -> Identifier()
    * f2 -> "alias?"
    * f3 -> Identifier()
    * f4 -> <SCOMMENT2>
    */
   public void visit(Query n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         String id1 = tokenName;
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         String id2 = tokenName;
         function_object.queries.add(new Pair<String,String>(id1,id2));
         n.f4.accept(this, argu);
      }
      else if(x == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
      }
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | FieldAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public void visit(Statement n, A argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> "{"
    * f1 -> ( QStatement() )*
    * f2 -> "}"
    */
   public void visit(Block n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public void visit(AssignmentStatement n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
      }
      else if(x == 1)
      {
         message_send.clear();
         n.f0.accept(this, argu);
         String id = tokenName;
         message_send.add(id);
         n.f1.accept(this, argu);
         statement_type = -1;
         n.f2.accept(this, argu);
         int sm = statement_type;
         n.f3.accept(this, argu);
         Pair<String,Integer> p = get_type(id); 
            if(sm == 1)
            {
               //simple assignment.
               if(classes.containsKey(p.first) || p.first.equals("int[]")){//arrays or object types.
               if(!function_object.assignment_statements.containsKey(id))
                  function_object.assignment_statements.put(id,new HashSet<String>());
               Set<String> s = function_object.assignment_statements.get(id);
               s.add(exp_id1);
               function_object.assignment_statements.put(id,s);
            }
         }    
            else if(sm == 2)
            {
               //Either an object or an array allocation statement. exp_id1 has the allocation reference.
               if(classes.containsKey(p.first) || p.first.equals("int[]")){//arrays or object types.
               if(!function_object.allocation_statements.containsKey(id))
                  function_object.allocation_statements.put(id,new HashSet<Integer>());
               Set<Integer> s = function_object.allocation_statements.get(id);
               s.add(Integer.parseInt(exp_id2));//exp_id1 is the type, exp_id2 is the abstract location.
               }
            }
            else if(sm == 3)
            {
               //field load. Can be loaded into a class field or local variable, have to be careful. For now assume simple load.
               if(classes.containsKey(p.first) || p.first.equals("int[]")){//arrays or object types.
               function_object.field_loads.add(new Pair<String,Pair<String,String>>(id,new Pair<String,String>(exp_id1,exp_id2)));
            }}
            else if(sm == 4)
            {
               //message send.
               String[] s = new String[message_send.size()];
               int i = 0;
               for(String t: message_send)
                  s[i++] = t;
               function_object.function_calls.add(s);
            }
         message_send.clear();
         statement_type = -1;
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Identifier()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Identifier()
    * f6 -> ";"
    */
   public void visit(ArrayAssignmentStatement n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "="
    * f4 -> Identifier()
    * f5 -> ";"
    */
   public void visit(FieldAssignmentStatement n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
      }
      else if(x == 1)
      {
         n.f0.accept(this, argu);
         String id1 = tokenName;
         Pair<String,Integer> p = get_type(id1);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String id2 = tokenName;
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         String id3 = tokenName;
         n.f5.accept(this, argu);
         String t = get_field_type(p.first, id2);
         if(classes.containsKey(t) || t.equals("int[]"))
         {
            //this is a write to a reference type class field. Needs to be updated. 
            function_object.field_writes.add(new Pair<Pair<String,String>,String>(new Pair<String,String>(id1,id2),id3));
         }
      }
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public void visit(IfStatement n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public void visit(WhileStatement n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> ";"
    */
   public void visit(PrintStatement n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
   }

   /**
    * f0 -> AndExpression()
    *       | CompareExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | FieldRead()
    *       | PrimaryExpression()
    */
   public void visit(Expression n, A argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "&&"
    * f2 -> Identifier()
    */
   public void visit(AndExpression n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "<"
    * f2 -> Identifier()
    */
   public void visit(CompareExpression n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "+"
    * f2 -> Identifier()
    */
   public void visit(PlusExpression n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "-"
    * f2 -> Identifier()
    */
   public void visit(MinusExpression n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "*"
    * f2 -> Identifier()
    */
   public void visit(TimesExpression n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Identifier()
    * f3 -> "]"
    */
   public void visit(ArrayLookup n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> "length"
    */
   public void visit(ArrayLength n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> Identifier()
    */
   public void visit(FieldRead n, A argu) {
      n.f0.accept(this, argu);
      String a1 = tokenName;
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      String a2 = tokenName;
      exp_id1 = a1;
      exp_id2 = a2;
      statement_type = 3;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ArgList() )?
    * f5 -> ")"
    */
   public void visit(MessageSend n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
      }
      else if(x == 1)
      {
         part_of_call = true;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String called_fn = tokenName;
         message_send.add(called_fn);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         n.f5.accept(this, argu);
         statement_type = 4;
         Pair<String,Integer> ty = get_type(message_send.get(1));
         String ty1 = ty.first;
         for(String ty2: classes.keySet())
         {
            if(is_subtype(ty1,ty2))
            { 
               while(ty2 != null)
               {
                  ClassTable ct1 = classes.get(ty2);
                  if(ct1.functions.containsKey(called_fn))
                  {
                     function_object.called_functions.put(new Pair<String,String>(ty2,called_fn),true);
                     break;
                  }
                  ty2 = ct1.parent;
               }
            }
         }
         part_of_call = false;      
      }
   }

   /**
    * f0 -> Identifier()
    * f1 -> ( ArgRest() )*
    */
   public void visit(ArgList n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      else
      {
         n.f0.accept(this, argu);
         String id = tokenName;
         message_send.add(id);//don't bother about types for now!
         n.f1.accept(this, argu);       
      }
   }

   /**
    * f0 -> ","
    * f1 -> Identifier()
    */
   public void visit(ArgRest n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      else if(x == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         String id = tokenName;
         message_send.add(id);
      }
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    */
   public void visit(PrimaryExpression n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
      }
      else if(x == 1)
      {
         n.f0.accept(this, argu);
         if(n.f0.which == 3)
         {
            exp_id1 = tokenName;
            if(part_of_call)
               message_send.add(exp_id1);
         }
         if(n.f0.which == 4)
         {
            exp_id1 = "this";
            if(part_of_call)
               message_send.add(exp_id1);
         }
         if(n.f0.which == 5)
         {
            //nothing to do here. 
         }
         if(n.f0.which == 6)
         {
            if(part_of_call)
            {
               String temp = String.format("__ialloc%d",inline_allocations);
               inline_allocations++;
               function_object.local_variables.put(temp,exp_id1);
               if(!function_object.allocation_statements.containsKey(temp))
                  function_object.allocation_statements.put(temp,new HashSet<Integer>());
               Set<Integer> s = function_object.allocation_statements.get(temp);
               s.add(abstract_locations-1);
               message_send.add(temp);
            }
         }
      }
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public void visit(IntegerLiteral n, A argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> "true"
    */
   public void visit(TrueLiteral n, A argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> "false"
    */
   public void visit(FalseLiteral n, A argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public void visit(Identifier n, A argu) {
      n.f0.accept(this, argu);
      exp_id1 = tokenName;
      statement_type = 1;
   }

   /**
    * f0 -> "this"
    */
   public void visit(ThisExpression n, A argu) {
      n.f0.accept(this, argu);
      exp_id1 = "this";
      statement_type = 1;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Identifier()
    * f4 -> "]"
    */
   public void visit(ArrayAllocationExpression n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
      }
      else if(x == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         abstract_types.put(abstract_locations,"int[]");
         abstract_locations++;
         exp_id1 = "int[]";
         exp_id2 = Integer.toString(abstract_locations-1);
         statement_type = 2;
      }
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public void visit(AllocationExpression n, A argu) {
      int x = Integer.valueOf((Integer)argu);
      if(x == 0)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
      }
      else if(x == 1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         String ty = tokenName;
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         abstract_types.put(abstract_locations,ty);
         abstract_locations++;
         exp_id1 = ty;
         exp_id2 = Integer.toString(abstract_locations-1);    
         statement_type = 2;
      }
   }

   /**
    * f0 -> "!"
    * f1 -> Identifier()
    */
   public void visit(NotExpression n, A argu) {
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
   }
}
